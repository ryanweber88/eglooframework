<?php
namespace eGloo\Domain;

use \eGloo\Utilities\Delegator;
use \eGloo\Utilities\InflectionsSafe;

/**
 * Superclass for all domain models; provides generic functionality
 * @author Christian Calloway callowaylc@gmail.com
 */
abstract class Model extends Delegator 
	implements \eGloo\Utilities\ToArrayInterface, \ArrayAccess {

	// this acts as a store for adding runtime instance properties
	// @TODO this will be replaced, as storing values will be delegated
	// in the future
	protected $properties = array();

	/**
	 * @param variable-length $__mixed
	 */
	function __construct($__mixed = null) {

		// pass to parent delegator::__construct our *DataAccess
		// instance or Domain\Data
		parent::__construct(static::data());


		// call our relationships method, which provides callbacks attached
		// to the names of our relationships
		$this->__relationships();
		
		// call __callbacks method, which defines behaviors during life cycle
		// of instance
		$this->__callbacks();
		

		// make sence of parameter - this will change as EPA
		// is folded into our domain model
		if ((is_array($__mixed) || $__mixed instanceof \ArrayAccess) && 
				\eGloo\Utilities\Collection::isHash($__mixed)) {
			
			$this->initialize($__mixed);
		}
				
		
		// finally call attributes, which sets up convience attributes for
		// instance		
		$this->__attributes();
				
		
	}

	/** @Polymorphic */ 
	public static function __static() {
		
	
		$class     = static::classNameFull();
		$signature = static::signature();
		$classname = static::classname();
		
			
		// assign static delegation 
		Delegator::delegate($class, get_class(static::data()));

		// provide reg exp list to check methods against
		$lookFor = array(
			'/^loadByI(D|d)$/'                    => 'find',
			"/^load{$classname}ByI(D|d)$/"        => 'find',
			'/^load([A-Z][a-z]+?)By([a-zA-Z]+)$/' => 'find_by_$1_$2',
			'/^get([A-Z][a-z]+?)By([a-zA-Z]+)$/'  => 'find_by_$1_$2',
			"/^load{$classname}List$/"            => 'all',
			"/^create{$classname}$/"              => 'create'
		);

		// retrieve list of methods from class
		$reflection = new \ReflectionClass($class);
		$methods    = $reflection->getMethods();
		$found      = array();		
		
		
		// iterate through patterns and check against our static methods
		// drawing up aliases where patterns match
		foreach($methods as $method) {

			//if ($method->getDeclaringClass()->getName() == $class) {
				 
				foreach($lookFor as $pattern => $alias) {				
					if (preg_match($pattern, $method->getName(), $match)) {
						
						// perform regexp replace on pattern, if applicable and
						// replace class name ( again, if applicable ) - these are
						// placed on two lines for readability 
						$alias = strtolower(\eGlooString::toUnderscores(preg_replace(
							$pattern, $alias, $method->getName()
						)));
						
						$alias = str_replace("{$signature}_", null, $alias);
						$from  = $method->getName();
						
						try {
							
							//echo "$alias to {$method->getName()} on $class<br />";
							//echo "found alias $alias for $from on class $class<br />"; 
							static::defineMethod($alias, function($arguments) use ($class, $from) {
							
								// call original method and pass to process which will convert
								// over to proper return type (null, Model, Set)
								$result = call_user_func_array(
									array($class, $from), func_get_args() 
								);	
																				
								return $class::sendStatic('process', $result);
								
							});
							
							
							// get fully qualified class name and call alias method - 
							// 'static' should work here, but it doesn't??
							//static::aliasMethod(strtolower(preg_replace(
							//	$pattern, $alias, $method->getName()
							//
							//)), $match[0]);
							
						}
			
						// since we are not looking for a "steadfast" rule,
						// we ignore any exception generated by the fact that
						// method does not exist - the only caveat here is
						// that
						catch(\Exception $ignore) {
							//exit('bizarre');
							echo $ignore->getMessage() . "<br />"; 
						}
						
						break ;
						
					}
				}

			//}
		}




		// explicitly define find if we haven't found a suitable alias;
		// we can't explicitly define this method because it would interfere
		// with aliases, which for the time being are more correct (specific)
		// @TODO these need to be moved to __methodStatic
		
		if ( !static::respondTo('find') ) {
										
			static::defineMethod('find', function($__mixed, $class) {
												
				// expand on parameter matching, but for, just match on primary
				// and tablename_id pattern
				$arguments = func_get_args();
				$table     = $class::sendStatic('signature');
				$field     = "{$table}_id";
				$key       = $arguments[0]; 
				
				
				// we're GAURENTEED to throw an exception here if our by-conventions guess
				// does not pan out; so callers will be explicitly aware
				try {
					
					/*
					return $class::sendStatic('process', $class::statement("
						SELECT
							*
						FROM 
							$table
						WHERE
							$field = ?
							
					", $key));
					 */
					$result = $class::sendStatic('process', $class::where(array(
						$field => $key
					)));
										
					// we know that if result is not absolute false, it will be returned
					// as a set from our process method
					if ($result) {
						$result = $result[0];
					}
					
					return $result;
					
				}
				
				catch(\Exception $passthrough) {
					throw $passthrough;
				}
				
				
			});
			
		}
		
		// explicitly define all, if not aliased and not explicitly defined
		
		if ( !static::respondTo('all') ) {
			static::defineMethod('all', function($class) {
					
				// expand on parameter matching, but for, just match on primary
				// and tablename_id pattern
				$arguments = func_get_args();
				$table     = $class::sendStatic('signature');
				$field     = "{$table}_id";
				$key       = $arguments[0]; 
				
				// we're GAURENTEED to throw an exception here if our by-conventions guess
				// does not pan out; so callers will be explicitly aware
				try {
					
					$set = $class::statement("
						SELECT * FROM $table
							
					");
					
					return $class::sendStatic('process', $set);
				}
				
				catch(\Exception $passthrough) {
					throw $passthrough;
				}
				
				
			});
		}
				
		// delegate our query building methods to Relation
		// @TODO we should delegate to scoped which should handle
		// the rest
		$reflection = new \ReflectionClass(static::classNameFull());
			
		// @TODO user is causing all kinds of fucking problem when not
		// receiving an initializing hash; so i am taking the bitch out
		// for the moment
		if (!$reflection->isAbstract() ) {
			
			
			static::delegates(array(
				'methods' => array('selects', 'search', 'like', 'where', 'from', 'join', 'limit', 'order', 'group'),
				'to'      => new Model\Relation(static::classNameFull())
			));
		}
	}
	
	protected function __methods() {
		parent::__methods();

		// Provides a callback/deferred space in which to group transactions;

		$this->defineMethod('transaction', function($lambda) {

			// @TODO trigger begin transaction
		
			try {
				$result = $lambda();
			} 
			
			catch(\Exception $pass) {
				throw $pass;
			}
			
			return $result;
		
		// @TODO trigger end transaction
	
		});
		
	}
	
	protected static function __methodsStatic() {
		
		$class = static::classNameFull();
		
		static::defineMethod('transaction', function($lambda) {
			throw new \Exception(
				"Class-level transaction support not implemented"
			);
		});
		
	}

	/**
	 * Responsible for initialize of model attributes
	 */
	protected function initialize(array $arguments) {
		
		$self = $this;
		
		$this->runCallbacks(__METHOD__, function() use ($self, $arguments) {
			 
			foreach($arguments as $name => $value) {
				
				// first check if a method exists with the same name
				// or if value is a lambda, in which case we define
				// as "callable" attribute
				if (\method_exists($self, $name) || is_callable($value)) {
						
					$self->send('attr', $name);
					
					//$reflection     = new ReflectionMethod($this, $name);
					
					
					// check parameter count is 1; we do this because we are assigning
					// one value in the context of intialize and we want to at least
					// try to avoid collisions; this isn't a fullproof method to
					// avoid collisions but will help
					//if ($reflection->getDeclaringClass()->getName() == $self->classNameFull() &&
					 //   $reflection->getNumberOfParameters() == 1) {
						
						// we want a method with the same name to act as arbiter to model
						// attribute
						//$self->send('attr', $name);
					//}
				}
	
				// now set value of attribute; if it has been defined as a callable attribute
				// then value will be routed through closure that $self->$name defines
				$self->$name = $value;
				
			}
		});
				
		// set flag 'initialized' to true
		$this->initialized = true;
		
	}

	/**
	 * Makes a determination if model has been initialized
	 */
	public function initialized() {
		return $this->initialized;
	}

	/**
	 * Determines if model exists as record in underlying database; 
	 */
	public function exists() {
		// @TODO this clearly needs to change - for right now, just check if id has been
		// set
		return isset($this->id) && !is_null($this->id);
		//return $this->initialized();
	}

	/**
	 * Overrides Object::aliasProperty to place property
	 * in properties member as well
	 */
	protected function aliasProperty($alias, $from) {
		parent::aliasProperty($alias, $from);
		
		//$this->properties[$alias] = &$this->properties[$from];
	}

	/**
	 * Convenience method to specify 1 - 1 relationships; note that you
	 * must still follow plurality conventions
	 */
	protected function hasOne($name, $lambda) {
		if (InflectionsSafe::isSingular($relation = preg_replace('/\s+as\s+([A-Z].*)$/', null, $name))) {
			return $this->defineRelationship($name, $lambda, true);
		}
		
		throw new \Exception(
			"Failed to create relationship '$relation' because it does not follow singularity convention"
		);
	}
	
	/**
	 * Either provides an alias to hasOne (but more idiomatic), or answers the question
	 * of whether model belongsTo another
	 */
	protected function belongsTo($name, $lambda = null) {
		if (is_null($lambda)) {
			// @TODO this is not a foolproof scheme of determining whether relationship
			// is truely a 'belongs_to', but will do for now
			return $this->hasRelationship($name) &&
		         InflectionsSafe::isSingular($name);
			
		}
		
		return $this->hasOne($name, $lambda);
		


	}
	
	protected function hasMany($name, $lambda) {
		if (InflectionsSafe::isPlural($relation = preg_replace('/\s+as\s+([A-Z].*)$/', null, $name))) {
			return $this->defineRelationship($name, $lambda, false);
		}
		
		throw new \Exception(
			"Failed to create relationship '$relation' because it does not follow plurality convention"
		);
	}
	
	protected function hasRelationship($name) {
		return isset($this->relationships[$name]);
	}
	
	/**
	 * This is an alias to defineMethod - currently it is here for 
	 * idiomatic reasons only
	 * @type experimental the moment - will be used to indicate relationship
	 * type if plurality rules are ineffective
	 */
	protected function defineRelationship($name, $lambda, $singular = null) {
		// get model name, using inflection class
		// @TODO this will need to be changed as it doesn't
		// belong here
		//echo static::namespaceName(); exit;
				
		// check if an 'as Alias' has been specified
		$alias = null;
		
		if (preg_match($pattern = '/\s+as\s+([A-Z].*)$/', $name, $match)) {
			$name = trim(preg_replace(
				$pattern, null, $name
			));
			
			$alias = $match[1];
		}
		
		$relationshipName = $name;
		$name             = ucfirst(\eGloo\Utilities\InflectionsSafe::instance()
						          ->singularize($name));
		//$ns               = $this->namespace();
		
		//echo "-- " . static::classNameFull() . " has $name<br />"; 
	
		
		// @TODO this has to be determined dynamically, but for the time being
		// will ensure that proper model is instantiated if attempting an alias
		// call on \Model will return \Common\Domain\Model\*
		$ns               = '\\Common\\Domain\\Model';
		$self             = $this;
		
		// determine relationship type based on either $singular parameter, 
		// which takes prescedence, or looks at plurality using inflections
		$singular = $singular === true
			? $singular
			: InflectionsSafe::isSingular($relationshipName);
			
		// if class does not exist, then replace with generic	handler
		if (!class_exists($model = "$ns\\{$this->className()}\\$name") && !class_exists($model = "$ns\\$name"))	{
			$model = "$ns\\Generic";
		}
		
		
			
		//if (class_exists($model = "$ns\\{$this->className()}\\$name") || class_exists($model = "$ns\\$name")) {
		//if (1) {
		$relationships = &$self->reference('relationships');
		$relationships[$relationshipName] = $model;
		

		//echo "relationship model '$model'"

					
		//@TODO using ternary below may be hard to read
		return $this->defineMethod(is_null($alias) ? $relationshipName : $alias, function() use ($model, $self, $relationshipName, $lambda, $singular, $alias) {
			
			
			// get reference to relationships and make reference that relationship is
			// beging created
			$result = null;

			
			// check if the model exists in the database to ensure we are
			// not running queries against an empty/shallow model - because
			// there is nothing to match against here
			if ($self->initialized()) {
				$result = $lambda($model);
				
				// if returned result is an instance of relationship, which is a query build tool
				// then evaluate and pass to statement
				// @TODO the relation should be responsible for the build of model instance, not just
				// as a query build tool - this will have to be addressed, but converting right now
				// will present too much variability
				if ($result instanceof Model\Relation) {
					try { 
						$result = $result->build();
					}
					
					catch(\Exception $passthrough) {
						throw $passthrough;
					}

				}

				// check if singular result or hash (which would indicate
				// a single record being returned); if an array is returned
				// then it should contain 1+ elements as this is-a required
				// contract of the defineRelationship method
				if (is_array($result)) {
					
					
					if (\eGloo\Utilities\Collection::isHash($result)) {						
						$result = new $model($result);
						
			
						// @TODO this is a shortcut to we establish a better rule
						// in terms of convetion around singular vs set
						
						if (!$singular) {
							$result = new Model\Set(array($result));
						}	
						
					}
					
					// otherwise we have a set return; check if elements are
					// model instances, in which case we can simply wrap
					// reset in set instance
					else if ($result[0] instanceof Model) {

						$result = new Model\Set($result);
					
					}
					
					// otherwise, we manually build set with model instances
					else {
						
						foreach($result as $record) {
							$temporary[] = new $model($record);	
						}
						
						// replace result with temporary
						$result = new Model\Set($temporary);
					}
					
				}
				
			}




			
			// if the model doesn't exist (the case where we have a "shallow"
			// model) or our return result from lambda is false (which indicates 
			// an empty result or a failure to find data), 
			// we return a shallow copy of our relationship(s), either as an instance
			// of model or emptyset, based on plurality rules
			
			if (!$result) {

				$result = $singular
					
					// return an empty instance of model
					? new $model
					
					
					: new Model\Set($model);
				
			}
			
			// because our find_by methods returns sets automatically, we need to
			// check $singular argument to see if this is truely intended
			else if ($singular && $result instanceof Model\Set) {
				$result = $result[0];
			}
			
			// otherwise we return result as is, which can be any value outside
			// of null
			return $result;
		});
			
		
		

		//throw new \Exception(
		//	"Failed to define relationship \"$name\" because model \"$model\" does not exist"	
		//);
		
	}

	/**
	 * The point of trapping the defineMethod event is to determine
	 * if any names match that of attributes, in which case we replace
	 * the current handler or value with the new handler
	 * 
	 */
	protected function methodAdded($name, $lambda) {
		if (isset($this->_attributes[$name])) {
			$this->attrAccessor($name);
		}
	}
	 
	/**
	 * Provides a variable length argument list of items that
	 * must exist prior to certain callbacks
	 */
	protected function validates($__mixed) {
		$this->validates = is_array($__mixed[0])
			? $__mixed
			: func_get_args();
	}
	
	/**
	 * Determines if model is valid based on attribute values specified
	 * in validates
	 */
	public function valid() {
		
		// run our validation callbacks
		$this->runCallbacks('validate');
		
		// explicitly check fields
		foreach($this->validates as $attribute) {	
			//$hasAttribute = "has_$attribute";
			
			if (!isset($this->$attribute)) {
				return false;
			}
		}
				
		return true;
	}
	
	/**
	 * Returns a printout of validation failures; this should only be used 
	 * during testing
	 */
	public function whatsInvalid() {
		
		// right now just return a list of invalid fields
		$attributes = array();
		
		foreach($this->validates as $attribute) {
			
			if (!isset($this->$attribute)) {
				$attributes[] = $attribute;
			}
		}
		
		return $attributes;
	}
	
	/**
	 * Convenience method meant to return array of values from
	 * fields specified in arguments list; is not mindful of 
	 * whether field values exists or not
	 */
	public function values($__mixed) {
		$fields = is_array($__mixed[0])
			? $__mixed
			: func_get_args();
		
		foreach($fields as $name) {
			$values[] = $this->$name;
		}
		
		return $values;
	}

	
	/**
	 * A stubb method here to be used by concrete model classes
	 */
	protected function __relationships() {
		
		$class     = $this->classname();
		$namespace = $this->namespace();
		
		// check for status relationship and draw if exists, we could
		// explicitly do this in a try/catch, but would present a serious
		// issue were someone to write a generic Common.Domain.Model.Status
		// class; so here, our convention is "if there is a Status class
		// in Comon.Domain.Model.$ClassName namespace, then define status
		// relationship"
		if (class_exists($model = "$namespace\\$class\\Status")) {
			$self = $this;

			$this->hasOne('Status', function() use ($self, $model) {
				return $model::find($self->status_id);
			});
			
						
		}
		
	}

	protected function __callbacks() {
		
		$self = $this;
		
		// define a generic create callback based on
		// model convention if there currently 
		$this->defineCallback('create', function() use ($self) {
			// check that a create callback has not already been created - this is to ensure
			// we don't face double inserts
			// @TODO since this was added late in the lifecycle of model design, there already
			// exist many create callbacks - until this is cleaned up, we have to specifically
			// check for the existence of create
			$callbacks = &$self->reference('callbacks');
			
			if ($self->send('hasCallbacks', 'create', 'around') && count($callbacks['create']['around']) == 1) {
			
				// get instance attributes - strip the primary key if 
				// is in list of attributes and has a null value
				$attributes = $self->attributes();
				$signature  = $self->send('signature');
				
				// apparently an associative array key with an associated value of nil is
				// considered unset, #wtfphp
				if (isset($attributes[$pk = $self->primaryKeyName()]) || 
				    is_null($attributes[$pk])) {
				
					unset($attributes[$pk]);			
				}
						
				try {
					// set primary key with result of insert - if it has been succesfully aliased,
					// then value will be updated on true primary key
					// @TODO composite keys? 
					$self->id = $self::inserts(array(
						'into'         => $self->send('signature'),
						'with_columns' => array_keys($attributes),
						'using'        => array_values($attributes)
					));	
					
				}
				
				// since we guesing on this insert, we ignore sql errors and make a determination
				// in inherited classes whether insert was successful
				catch(\Exception $ignore) {
					//throw new \Exception(
					//	"Default create failed but can be overriden using setCallback(create, lambda). " . 
					//	"The following message was returned : \n$append "
					//);
				}	
			}	
			
		});
		
		
		// define a generic create callback based on
		// model convention
		$this->defineCallback('update', function() use ($self) {
			
			// check that a create callback has not already been created - this is to ensure
			// we don't face double inserts
			// @TODO since this was added late in the lifecycle of model design, there already
			// exist many create callbacks - until this is cleaned up, we have to specifically
			// check for the existence of create
			$callbacks = &$self->reference('callbacks');
			
			if ($self->send('hasCallbacks', 'update', 'around') && count($callbacks['update']['around']) == 1) {
				// get instance attributes
				$attributes = $self->attributes();
				$signature  = $self->send('signature');
				
				try { 
					$self::updates(array(
						'against'      => $self->send('signature'),
						'with_columns' => array_keys($attributes),
						'using'        => array_values($attributes)
					));	
					
				}
				
				// again, since this is a guess, we ignore exception and make determination that
				// update succeeded in child classes
				catch(\Exception $append) {
					//throw new \Exception(
					//	"Default create failed but can be overriden using setCallback(create, lambda). " . 
					//	"The following message was returned : \n$append "
					//);
				}		
			}
		});
				
	}

	/** ArrayAccess Interface **************************************************/
	// ArrayAccess interface is intended to be used to access attribute values
	// from within override setters; though the methods are public, it is not
	// truely intended for outside access
	
	public function offsetGet($attribute) {
		return $this->_attributes[$attribute]['value'];
	}
	
	public function offsetSet($attribute, $value) {
		$this->_attributes[$attribute]['value'] = $value;
	}
	
	public function offsetExists($attribute) {
		return isset($this->_attributes[$attribute]);
	}
	
	public function offsetUnset($attribute) {
		unset($this->_attributes[$attribute]);
	}
	
	
	
	
	/** Callbacks **************************************************************/
	
	/*
	protected function beforeCreate() { }
	protected function beforeSave()   { }
	protected function beforeUpdate() { }
	*/
	

	
	/**
	 * @param variable-length $__mixed
	 */
	static function __constructStatic($__mixed = null) {
		static::defineMethod('columns', function() {
			throw new \Exception('columns not implemented - because it sucks');
		});
	}
	
	/**
	 * Attempts to find a model's "signature" which is a pattern based on namespace + class;
	 * basically everything appearing after "model" in namespace will be underscored 
	 */
	protected static function signature() {
		// get signature pattern - so Common\Domain\ModelProductOption\Status, will be
		// converted to product_option_status; this could have been accomplished on 
		// one line, but we sacrifice readability
		$tokens    = explode('\\', preg_replace('/^.+Model[\\\]?/', null, static::classNameFull()));
		$signature = strtolower(\eGlooString::toUnderscores(implode('_', $tokens)));
		
		return $signature;
	}
	
	/**
	 * Provides an array representation of modelphp 
	 */
	public function __toArray() {
		
		// wrap our current domain\model instance in arrayaccess 
		// in most instances, this will be to our smarty instance
		// which should only accept type scalar or array
		return new Utility\ArrayAccess(
			$this	
		);
		
	}	
	
	/**
	 * Alias to __toArray; this is meant to be called explicitly
	 * wherein __toArray satisfies the conditions of our ToArrayInterface;
	 * also, there are conditions where we simply cannot accept an
	 * object, even one that caters to array notation, so thus
	 * 
	 */
	public function toArray($wrapped = false) {
		if ($wrapped) {
			$returns = $this->__toArray();	
		}
		
		else {
			$values = array();
			
			foreach($this->attributes as $field) {
				$values[$field] = $this->$field;
			}
			
			$returns = $values;
		}
		
		return $returns;
	}
	
	/**
	 * Returns a list of attributes as associative array
	 * @TODO this currently only works if instance exists - 
	 * given the way model works, this perhaps should be the
	 * required/intended behavior
	 * @TODO name may be too close to __attributes?
	 * @return mixed[]
	 */
	public function attributes() {
		
		$values = array();
						
		// iterate through properties, retrieve values and return
		foreach($this->attributes as $field) {
			
			// @TODO there is a chance here that an alias may have the same
			// name as a property
			if (!$this->isAliasedProperty($field)    &&
			    !$this->hasRelationship($field))     {
			    	
				$values[$field] = $this->$field;
			}
			
		}
		
		return $values;
		
	}

	
	protected function __attributes() {
		// call our parent method to ensure any property work is done
		// up hierarchy chain
		//parent::__properties();
		
		// from ClassNameYada derive pattern class_class1_class2
		$class = static::signature();
		
		// @TODO this is a temporary measure, don't know if it will work, but
		// some code still refers to properties
		//$this->aliasProperty('properties', 'attributes');
	
				
		
		if ($this->initialized()) {

					
					
			// iterate across properties and determine if they
			// fit pattern of $class_(name)
			// @TODO replace self reference - stupid 5.3 issue
			$self = $this;
					
			
			// @TODO static cache is not working here - needs to be
			// polymorphic
			$attributes = static::cache($class, function() use ($self) {
				return $self->reference('attributes');
			});
			


								
			foreach($attributes as $name) {
	
				
				// in some instances, for sub model types, like coupon\type, our convention doesn't work for
				// fields with the same name as the class (ie, coupon_type.coupon_type); in these cases we
				// look for a field matching the exact name
				$match = array();
				
				if (preg_match("/{$class}_(.+)/", $name, $match) || $name == $class) {
					
					
					$alias = $name == $class
						? preg_replace('/^.+_/', null, $name)
						: $match[1];
						
						
					try { 
						$this->aliasProperty(
							strtolower($alias), $name	
						);
					}
	
					catch(\Exception $ignore) { }
				}
	
			}
		

			
				
			// @TODO right now we are auto aliasing primary key, but this will cause corrupted data
			// with model; in the future need to determine existence of primary key and cache 
			// beforehand
			$this->aliasPrimaryKey("{$class}_id");
			
	
			
			// check if model has status relationship
			// @TODO this may be a bit too specific for this instance
			if (isset($this->status_id)          &&
			    $this->hasRelationship('Status')  && 
			    $this->Status->exists()) {
			    	
				$field = "{$this->signature()}_status";
				$this->status__ = $this->Status->$field;
			}		
		}
	
			
	}
	
	
	
	
	/**
	 * Create method is a really wrapper to instantiate model, and then
	 * call save
	 * @return Model
	 * @param  variable-length[] $__mixed
	 */
	public static function create($__mixed = null) {
				
		// because create can be sent to both instance and class
		// receivers, we have to explicitly check to determine 
		// who are reciever is; in the former case, receiver is
		// passed as argument and should never been be external
		// to Model
		$arguments = func_get_args();
		
		// check if receiver has beenb passed as argument 
		if (isset($arguments[0]) && ($self = $arguments[0]) instanceof Model) {
			
			// because runCallbacks is a protected method, we use the send method 
			// to by-pass access modifier; sorry folks, this is the only way to do
			// this without creating a static create and instance create method
			$self->send('runCallbacks', __FUNCTION__);
			
		}
			
		
		// instantiate model and explicitly set primary key to nil; this will ensure
		// that a record is created as opposed to an update - the onus lies
		// upon the developer that they do not do an explicit call on create
				
		else if ( \eGloo\Utilities\Collection::isHash($arguments = $arguments[0]) ) {
			
			$model     = new static($arguments);
			$model->id = null;
						
			
			// saves model to underlying data layer and sets
			// initialized to true
			$model->save();
			$model->initialized = true;
			
			// return model to caller
			return $model;
		}
		
		// otherwise we have passed an invalid argument to create and
		// we throw an exception to that fact
		else {
			$class = static::getCalledClass();
			
			throw new \Exception(
				"Failed to create instance of '$model' because argument(s) are invalid " . print_r(
					$__mixed
				)
			);
		}
	}

	/*
	public static function find($__mixed) {
		if (isset($arguments[0]) && ($self = $arguments[0]) instanceof Model) {
		 
			
		} else {
			
			// flatten arguments - this will always return an array
			$arguments = \eGloo\Utilities\Collection::flatten($__mixed);
			$models    = array
			// iterate through arguments, 
			foreach($arguments as $key) {
				
			}
				
		}
		
	}
	 * 
	 */
	
	public function save($cascade = true) {
		
		
		// we ask the question again, if valid, after performing
		// our validation routines
		if ($this->valid()) { 
			// execute our save callbacks
			$this->runCallbacks(__FUNCTION__);
			
			// flag to detemrine if running a create operation; this is important
			// for cascading save operations, as updates do not cascade save
			// on has many relationships
			$isCreate = false;
			
			// based on whether model primary key is set, call the correct
			// action method
			if ($this->exists()) {
				
				$model = $this;
			
				if ($this->changed() || 
				    isset($this->overrides_changed) && $this->overrides_changed === true) {
				    	
					$this->update();
				}				
		
			}
			
			else {
				// unfortunately this has be passed here as we can call static
				// context, but not have static funciton be aware of instance
				$model = $this->create($this);
			}
			
			// reset our changed, since model is now (theoretically) in 
			// parrallel to database
			$model->changed = array();
		}
		
		// lets see what is missing for validation and throw exception
		else { 
			throw new \Exception(
				"Cannot save model because the attributes did not pass validation : " . print_r(
					$this->whatsInvalid(), true
			));
		}
		
		
		// @EXPERIMENTAL = we are going to run through our relationships
		// and determine if they have been created - if not, we attempt
		// to create them
		// @TODO this should be pushed into a callback, not has a "hard-code"
		// here
		
		if ($cascade) { 
			foreach($model->relationships as $relation) {
				
				// determine if a hasOne relationship and if initialized - 
				// which case save
				// @TODO this needs to be abstracted to Model.Relation
				if ($relation instanceof Model && 
				    $relation->initialized()   &&
						$relation->changed()) {
							
					try { 
						$relation->save();
					}
					
					// a not changed exception we ignore, as this will be the case
					// in many instances
					catch(Model\Exception\Update\NotChanged $ignore) { }
					
					catch(\Exception $pass) {
						throw new $pass;
					}
					
				}
				
				// we ONLY do updates on has_many relationships on a create event
				else if ($isCreate && (($relations = $relation) instanceof Model\Set)) {
				
					foreach($relation as $relation) {
						if ($relation->initialized() && $relation->changed()){
							try {
								$relation->save();
							}
							
							catch(Model\Exception\Update\NotChanged $ignore) { }
							
							catch(\Exception $pass) {
								throw new $pass;
							}
						}
					}
				}
			}
		}
		
		return $model;
		

				
	}




	
	
	public function update() {
		$this->runCallbacks(__FUNCTION__);
	}
	
	public static function delete($key = null) {
		if (isset($this)) { 
			return $this->runCallbacks(__FUNCTION__);
		}
		
		else {
			$model = static::find($key);
			return $model->delete();
		}
	}
	
	
	/**
	 * Adds a callback of type $event, to a specific point (before, around, after)
	 * and pushes callback $lambda on event + point stack
	 */
	protected function defineCallback($event, $mixed, $lambda = null) {
	
		$point = $mixed;
	
		if (is_null($lambda) && is_callable($mixed)) {
			$lambda = $mixed;
			
			// @TODO 'around' should not be specified inline
			$point  = 'around';
		}
	
		if (is_callable($lambda)) {
			$this->callbacks[$event][$point][] = $lambda;
		}
	
		else {
			throw new \Exception(
					"A block/lambda must be provided when defining a callback"
			);
		}
	
	}
	
	/**
	 * Does the same as defineCallback, but first unsets an event + point callback stack and
	 * pushes on new event
	 */
	protected function setCallback($event, $mixed, $lambda = null) {
	
		$point = $mixed;
	
		if (is_null($lambda) && is_callable($mixed)) {
			$lambda = $mixed;
			
			// @TODO 'around' should not be specified inline
			$point  = 'around';
		}
	
		if (is_callable($lambda)) {
			// reset our callback stack
			$this->callbacks[$event] = array();
			
			// now push first callback on stack
			$this->callbacks[$event][$point][] = $lambda;
		}
	
		else {
			throw new \Exception(
					"A block/lambda must be provided when defining a callback"
			);
		}
	
	}
	
	/**
	 * Determines if an event + point callback stack exists
	 */
	protected function hasCallbacks($event, $point) {
		// reference callbacks so my fingers fall off
		$cs = &$this->callbacks;
		
		// now return condition
		return isset($cs[$event])         && 
		       isset($cs[$event][$point]) && 
		       count($cs[$event][$point]);
			
	}
	

	
		
	protected function runCallbacks($event, $lambda = null) {
		
		// we use inject idea to pass values between callbacks,
		// if needed; if any callback returns false, then
		// we short-circuit execution
		$inject = true;
		
		// run our before/around callbacks
		foreach(array('before', 'around') as $point) {
			if (isset($this->callbacks[$event][$point])) {
				foreach($this->callbacks[$event][$point] as $callback) {
					if (($inject = $callback($inject)) === false) {
						return ;
					}
				}
			}		
		}
		
		// if we have wrapped functionality into our lambda
		// parameter; the intention is to run in between our before
		// and after callback events
		if (is_callable($lambda)) {
			$lambda();
		}
		
		// run our after callbacks in reverse order
		if (isset($this->callbacks[$event]['after'])) { 
			foreach(array_reverse($this->callbacks[$event]['after']) as $callback) {
				if (($inject = $callback($inject)) === false) {
					return ;
				}
			}
		}
		
		// @TODO retrieving a value from a callback seems 
		// like it is not the best idea, make but
		return $inject;
	
	}

	/**
	 * "Shapes" a result set into either a model or
	 * set of models; I don't know if I like the name of this
	 * method, so it is subject to change
	 * @return Model | Model\Set
	 */
	protected static function shape($result) {
		
		if ($result instanceof Model\Relation) {
			$result = $result->build();
		}
		
		else if (is_array($result) && count($result)) {
					
			if (\eGloo\Utilities\Collection::isHash($result)) {
				$result = new static($result);					
			}
					
			// otherwise, we manually build set with model instances
			else {
				
				$set = array();
				
				// check if result is composed of a list of Model
				// instances; then we set temporary to result list
				if ($result[0] instanceof Model) {
					$set = $result;
				}
				
				// otherwise, result list is set of
				// of associative arrays; we wrap each index
				// in Model instance
				else { 
					foreach($result as $record) {
						$set[] = new static($record);	
					}
				}
				
				// replace result with temporary
				$result = new Model\Set($set);
			}				
		}
		
		return $result;
	}
	
	/**
	 * Alias to shape, which sucks as a method name
	 */
	protected static function process($result) {
		return static::shape($result);
	}
	
	

	
	/**
	 * Aliases our primary key to 'id'
	 */
	protected function aliasPrimaryKey($from) {
		// for now we ignore our exception as primary
		// has already been aliased	
		try {
			$this->aliasProperty( 'id', $from );
		}
		
		catch(\Exception $ignore) {
			//var_export($ignore); exit('asdf');
		}
		

		$this->primaryKeyName = $from;
	}
	
	/**
	 * This is an alias of ObjectSafe#aliasProperty - since dynamically bound
	 * properties on a model are termed "attributes", "aliasAttribute" is
	 * moreso fitting
	 */
	protected function aliasAttribute($alias, $attribute) {
		
		// attribute is callable, then lambda should return a reference to the
		// attribute in question, to which our alias will become a true
		// alias of
		if (is_callable($lambda = $attribute)) {
			// make sure that lambda returns a reference, if it does
			// not we are creating a true alias and throw an exception
			// if the case
			$reflection = new \ReflectionFunction($lambda);
			
			if ($reflection->returnsReference()) {
				
				// we HAVE to set a !isset value to null first, otherwise an
				// assignment by reference will call __get first, which will
				// result in a thrown exception, because $alias does not yet
				// exist on this receiver
				//if (!isset($this->$alias)) {
				//	$this->$alias = null;
				//}
				
				// unset our attribute; this will make sure referenced values
				// are not unset as well
				unset($this->$alias);
				
				// now specify alias as attribute accessor and set with
				// value as lambda
				$this->defineMethod($alias, $lambda);
			}
			
			else {
				throw new \Exception(
					"Failed to create alias '$alias' because lambda does not return-by-reference"
				);
			}
		}
		
		else {
			$this->aliasProperty($alias, $attribute);
		}
	}
	
	/**
	 * Uses reflection/polymorphism to determine caller name, from
	 * which we derive the name of our *DataAccess class; this simply
	 * serves as a convenience to access *DataAccess::instance()
	 * @return Data
	 * @param variable-length $__mixed 
	 * @TODO is this even needed anymore if we are delegating to data class?
	 */
	protected static function data($__mixed = null) {
		$className     = static::classNameFull();
		$dataClassName = static::classNameFull() . 'DataAccess';

		$interface = class_exists($dataClassName)
			? $dataClassName::instance()
			: new Data;
		
		// Model::data will allow us to pass arguments to invoke funcitonality
		// directly on dataaccess, or pass in a lambda to access instance - 
		// this may expand as need arises
		if (count($arguments = func_get_args())) {
			
			// in this instance we will be dynamically invoking a method and passing
			// any additional parameters as arguments to invoked method
			// @TODO I don't know if this really needed, over say data()->method
			// but does provide some niceities in terms of clean presentation
			if (is_string($method = $arguments[0])) {
				return call_user_func_array(
						array($interface, $method), array_slice($arguments, 1)
				);
			}
			
			// in the instance of passing a lambda/block, we will pass the interface to
			// the lambda and return to caller the return from lambda
			else if (is_callable($lambda = $arguments[0])) {
				return $lambda($interface);
			}
		}
		
		return $interface;
		
	}

	/**
	 * Checks equality against model primary key value and type
	 * @return boolean
	 */
	public function equals(Model $model) {
		if ($model instanceof static) {
			// we surround with try catch in-case model has not been
			// initialized, or primary key is unavailable; in these
			// cases, checking equality is pointless so we return false
			// as opposed to raising an exception message
			try {
				return $model->id == $this->id;
			}
			
			catch(\Exception $ignore) { }
		}
		
		return false;
	}


/**
	public function __call($name, $arguments) {
		

		try { 
			return parent::__call($name, $arguments);
		}
		catch (\Exception $deferred) { }
		
		// if unable to find matching meta call within
		// __call chain, determine if 
		
		throw $deferred; 
	}
**/
	
	public static function __callstatic($name, $arguments) {
		
		try {
			//echo get_called_class() . "\n";
			//echo "calling static $name on receiver " . get_called_class() . "<br />";
			return parent::__callstatic($name, $arguments);
		}
		catch(\Exception $deferred) { }
		
		// if unable to find matching meta call within
		// __call chain, determine if a dynamic finder
		
		
		if (preg_match('/^find_(one_)?by_(.+)$/', $name, $match)) {
			$class   = static::classNameFull();
			$fields  = explode('_and_', $match[2]);
			$findOne = !empty($match[1]); 
			
						
			// now lets define out dynamic finder function
			$block = static::defineMethod($name, function($__mixed) use ($class, $fields, $findOne, $name) {
				
				
				
				// get table name using convetion of ModelName to model_name; this will
				// not fit in all cases and exception will be thrown from query if this
				// is the case
				$table = $class::sendStatic('signature');
				
				// build string representation of query coinditionals
				$conditions = array();
				
				foreach($fields as $field) {
					$conditions[] = "$field = ?";
				}
				
				$conditions = implode(' and ', $conditions); 
				$arguments  = func_get_args();
				
				// @TODO this is a temporary measure because ObjectSafe will pass in
				// class context as last parameter, which causes our result below
				// to break; for now, remove last argument if it matches $class
				if (($count = count($arguments)) > 1 && $arguments[$count-1] == $class) {
					unset($arguments[$count-1]);
				} 
				
				try {
					$result = $class::sendStatic('process', $class::where(
						$conditions, $arguments
					));
				}
				catch(\Exception $pass) {
					throw $pass;
				} 
				
				
				// if we have specified find_one_by then we return the first
				// instance - in most cases, this will be used when we know
				// there is only one corresponding record
				if ($findOne && $result instanceof Model\Set) {
					$result = $result[0];
				}
				
				return $result;
				
				
			});
			
			
			// now call our little pretty dynamic finder method
			return call_user_func_array(
		  	$block, $arguments 
			);
		}

		// dynamic range finders
		if (preg_match('/^find_(one_)?range_(.+)$/', $name, $match)) {
			$class   = static::classNameFull();
			$fields  = explode('_and_', $match[2]);
			$findOne = !empty($match[1]);
			
			/**
			// now lets define out dynamic finder function
			$block = static::defineMethod($name, function($__mixed) use ($class, $fields, $findOne) {
				
				$validRanges = true;
				
				// test whether we are passing range values like '4..10'
				foreach(func_get_args() as $range) {
					if (!\eGloo\Primitives\Range::valid($range)) {
						$validRanges = false;
						break;
					}		
				}
				
				// if not valid range, it is assumed that range is composed of parameter pairs, make
				// sure that the number of arguments matches number of fields * 2
				if ($validRanges) {
					
				}
				
				// get table name using convetion of ModelName to model_name; this will
				// not fit in all cases and exception will be thrown from query if this
				// is the case
				$table = $class::sendStatic('signature');
				
				// build string representation of query coinditionals
				$conditions = array();
				
				foreach($fields as $field) {
					$conditions[] = "$field = ?";
				}
				
				$conditions = implode(' and ', $conditions); 
				
				
				$result = $class::sendStatic('process', $class::where(
					$conditions, func_get_args()
				)); 
				
				// if we have specified find_one_by then we return the first
				// instance - in most cases, this will be used when we know
				// there is only one corresponding record
				if ($findOne && $result instanceof Model\Set) {
					$result = $result[0];
				}
				
				return $result;
				
				
			});
			 **/
		}
				
		throw $deferred;
	}
	

	/**
	 * Set/create properties on instance; this will
	 * eventually be removed and handled via delegated
	 * class
	 *
	 * @param type $key
	 * @param type $value
	 */
	public function __set($key, $value) {
		
		//echo "attempting set on $key\n";
		


		
		// we first attempt to resolve set within parent, which
		// is responsible for evaluating meta patterns. If they
		// do not exist, and property does not exist, then an 
		// exception will be thrown, which in this case is ignored
		// because we DO want dynamic properties/attributes added
		// to our receiver
		$continue = true;
		
		
		try {
			$continue = parent::__set($key, $value);
		}
		
		catch(\Exception $ignore)  {
			//echo $ignore; 
			$continue = true;
		}
		

		// if parent has thrown an exception, then meta tests have
		// failed and we intentionally wish to defined a dynamic 
		// property
		
		if ($continue) {
			
		 
			// because we rely on certain instance fields being set
			// during class definition (or when class is self) we
			// also set field on public
			// @TODO remove and place into properties when we
			// have figured out succesful toArray implementation
			// on our classes
			
			// override simple get functionality with method
			// @TODO not yet implemented
			if (\method_exists($this, $key)) {
				// pass	
			}
			
			// flag whether value has been changed, this is important
			// for checking 
			// @TODO this doesn't work because i am stupid, set will 
			// be bypassed after initial property set..  
			//$changed = !isset($this->$key) || 
			//           (isset($this->$key) && $this->$key !== $value);
			
			
			// we check if attribute has been set as lambda, in which case we avoid
			// a direct set (or arbitrarily creating a public property) as that would
			// bypass future calls to __get and __set, and thus undo the point of 
			// ruby style attributes
			// @TODO this is really messy, as its forced conglomerate of two different
			// concepts; eventually all attributes will be moved over to ruby style attribute
			// accessor
			if (!isset($this[$key])) {
				$this->$key = $value;
			}
			
			if (!in_array($key, $this->attributes)) {
				$this->attributes[] = $key;
			}
			
			// we also set on properties to maintain backwards 
			// compatibility on anything that is explicitly 
			// setting/getting on properties
			//$this->properties[$key] = $value;
			
		
			// now record change
			//@TODO this will always be true in initial set
			//if ($changed) { 
				$this->changes[$key][] = $value;
			//}
		}
		
		return $this;
	}

	/**
	 * Duplicates a model, but sets primary key to nil; this way, our on-save will invoke a create
	 * as opposed to update
	 */
	public function duplicate() {
		// creates a shallow copy of current instance	
		$dup = clone $this;
		
		// explicitly set primary to nil so record in essence "does-not_exist"; the
		// side-effect of this, is that calls to save will cause create action
		$dup->id = null;
		
		return $dup;
	}

	/**
	 * Returns a "by-convention" (ie, best guess) of what the primary
	 * key name is - this should not be relied upon unless we have an
	 * explicit understanding of underlying data structure; the methodology
	 * by which primary key is obtained will change in the future
	 */
	public function primaryKeyName() {
		
		if (!is_null($this->primaryKeyName)) {
			return $this->primaryKeyName;
		}
		
		throw new \Exception(
			"Failed to determine primary key name; it can be explicitly set using Model#aliasPrimaryKey"
		);
	}

	/**
	 * Determines if model instance has changed since initialization
	 */
	public function changed() {
		$self = $this;
		
		return $this->cache(function() use ($self) {
			if ($self->initialized()) {
				$changes = &$self->reference('changes');
				
				// iterate through change list - if a change property has more than one 
				// value in its change list, then it has clearly changed, thus marking
				// the model as changed
				foreach ($changes as $key => $values) {
					if (count($values) > 1) {
						return true;
					}
				}
			}
			
			return false;
		});
	}
	
	/**
	 * Explicitly lists changes 
	 */
	public function changes() {
		return $this->changes;
	}
	
	/**
	 * Locks any explicit changes on model
	 */
	public function lock() { }
	
	/**
	 * Get properties on instance that belong to
	 * our properties array; this will eventually
	 * be removed and handled on our delegated class
	 * 
	 * @param type $key
	 *
	 * @return mix type object retrieved from brand
	 *
	 */
	public function __get($name) {
				
		//if ( isset($this->properties[$key] )) {
		//	return $this->properties[$key];
		//}
		$class = strtolower( \eGlooString::toUnderscores(static::classname()) );
	

		// check if name has been defined in methods - if so, 
		// and method does not take arguments, call method
		if (isset($this->_methods[$name])) {
			
			//var_export($this->_methods)
			$reflection = new \ReflectionFunction(
					$this->_methods[$name]
			);
			
			
			
			// we don't want to use __get as replacement or alternative
			// to __call, but simply to call methods, which look like
			// properties, where it makes sense 
			if (count($reflection->getParameters()) == 0) {
				// for some reason, removing this allows us to see relationship in 
				// export statements (even the valid relationship model value is there..)
				//$this->$name = null;
				$this->$name = call_user_func(
						$this->_methods[$name]
				);
				
				// lets add an automatic bind of foreign key to relationship, if
				// it belongsTo current model instance
				if($this->$name instanceof Model && $this->$name->belongsTo($this->classname())) {
					//$field = $this->primaryKeyName;
					
					if (!is_null($this->$field)) {
						$this->$name->$field = $this->$field;
					}
				}
				
				return $this->$name;
			}
		}
		
		if ((preg_match('/^(.+?)(_?)Count$/', $name, $match))) {
			
			// convert to underscore to appease master
			if (\eGlooString::isCamelCase($match[0])) {
				$name = \eGlooString::toUnderscore();
			}
			
						
			if ($this->respondTo($match[1]) && \method_exists($this, $method = "__$name")) {
				if ($this->exists()) {
					return ($this->$name = $this->$method());
				}
				
				else {
					$class = static::classNameFull();
					
					throw new \Exception(
						"Failed to get count of association {$match[1]} because class '$class' does not exist"
					); 
				}
				
			}
		}

		// look for relationship using xxx_id pattern
		// and see if that relationship has been defined
		if (preg_match('/^(.+)_id/', $name, $match)) {
			$relationship = ucfirst($match[1]);
			
			if (isset($this->$relationship) && $this->$relationship instanceof Model) {
				// it is assumed that id field is set on model, whether it be null or not, it
				// should always alias to a primary key (or null if no primary key)	
				// @TODO fix relationship attribute alias
				$this->$name = null;
				$this->$name = &$this->$relationship->id;
				
				return $this->$name;
			};
		}
		
		// check for _change|changes pattern
		if (preg_match('/^(.+)_((change(s|d)?)|was)$/', $name, $match)) {
			$field  = $match[1];
			$action = $match[2]; 
			
			if (isset($this->$field)) {
				
				// 'changed' asks if field value has changed since originally
				// initialized value
				if ($action == 'changed') {
					$self = $this;
					
					return $this->cache($name, function() use ($self) { 
						return count($this->changes[$field]) > 1;
					});
				}
				
				// otherwise we are asking to see a list of explicit changes
				// for this field
				else if ($action == 'changes') {
					return $this->changes[$field];
				}
				
				// lastly, we determine original initialized value of
				// changes
				else {
					return $this->changes[$field][0];
				}
			}
			
			else {
				throw new \Exception(
					"Failed to determine change history because field '$field' does not exist on receiver " . static::classNameFull()
				); 
			}
		}

				
		if (\property_exists($this, $field = "{$class}_$name")) {
			$this->aliasProperty($name, $field);
			return $this->$name;
		}
		
		// check if primary key - this is temporary until better solution
		//$class = strtolower( \eGlooString::toUnderscores(static::classname()) );
		
		//if ($name == 'id' && \property_exists($this, $primaryKey = "{$class}_id")) {
		//	$this->aliasPrimaryKey($primaryKey);
		//	return $this->id;
		//}
				
		// if this is a new instance, and aliases have not been defined (since
		// we have not initialized; check to see if name is a match to class_name_property)
		// this has the danger of presenting very hard to track bugs, so we need to think
		// about legitimacy
		/*
		$class = strtolower( \eGlooString::toUnderscores(static::classname()) );
		echo "$class + $name<br />";
		
		if (property_exists($this, $field = "{$class}_$name")) {
			// @TODO having issues with alias property - doing it old fashioned way for now
			//$this->aliasProperty($name, "{$class}_$name");
			$this->aliasProperty($name, $field);
		}
		*/
		// otherwise pass to parent __get handler for higher level
		// processing

		
		return parent::__get($name);
			
		
		
	}	

	/**
	 * The purpose of a scope is to encapsulate chain calling
	 * and provide a chain-calling mechanism of its own
	 */
	protected function scope($name, $lambda) {
		
		return $this;
	}
	

	
	public function cast($class) {
		
		// allow for passing class namespace as Model.SubType, or Model::SubType
		$class = preg_replace('/(\.|::)/', '\\', $class);
			
		if (class_exists($class)) {
			return new $class($this->attributes());
		}
		
		throw new \Exception(
			"Cannot cast to model class '$class' because it does not exist"
		);
	}
		
	
	
	private function guessPrimaryKey() {
		// attempt to get primary key based on strlower(classname)_id pattern
		$tokens       = explode('\\', static::classNameFull());
		$primary_key  = strtolower(array_pop($tokens)) . '_id';
		
		return property_exists($this, $primary_key)
			? $primary_key
			: false;
		
	}
	
	static protected function factory($name) {
		/*
		$refle
		$class = static::namespace() . "\\Model\\$name";
	
		if (class_exists($class)) {
			return new $class;
		}
		*/
		throw new \Exception(
				"Failed to create model $class becfause it does not exist"
		);
	}	

	protected $attributes     = array();
	protected $validates      = array();
	protected $callbacks      = array();
	private   $initialized    = false;
	protected $changes        = array();
	protected $relationships  = array();
	protected $primaryKeyName; 
}

