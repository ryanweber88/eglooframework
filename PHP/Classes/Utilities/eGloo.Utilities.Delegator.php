<?php
namespace eGloo\Utilities;

// @TODO replace_object_safe
use \eGloo\Dialect\ObjectSafe as Object;

/**
 *  Provides proxying to wrapped instance via call & callstatic
 */
abstract class Delegator extends Object {

	function __construct($delegated) {
		parent::__construct();
		
		$this->delegated = $delegated;
	}
	


	/**
	 * Determines if method exists on delegated and call at instance level
	 * if the case
	 */
	public function __call($name, $arguments) {
		
		// we reverse the order of __call hierarchy, and first
		// attempt to find a match on parent::__call (we do not
		// want methods within delegated to take precedence)
		try {
			return parent::__call($name, $arguments);
		}
		
		// we will hold our exception for usage later
		catch(\Exception $hold) { }
		
		// create an instancer of Caller so we can determine
		// origin or caller context
		$caller = static::caller();
		
		// since php cannot make a determination between instance/static
		// receiver when called from an instance context, we have
		// to manually pass call to our callstatic dump
		if ($caller->isReceivedStatically()) {
			return static::__callstatic($name, $arguments);
		}

		
		if (!is_null($this->delegated) && method_exists($this->delegated, $name)) {

			return call_user_func_array(
					array($this->delegated, $name), $arguments	
			);
		}
		


		
		// convenience to delegate to receiver, which will be instantiated
		// dynamically
		if (preg_match('/^delegate_to_(.+)$/', $name, $match)) {
			$receiver = \eGlooString::toCamelCase(ucfirst($match[1]));
			$self     = $this;
			
			// 
			if (class_exists($receiver)) {
				$method = $this->defineMethod($name, function($__mixed) use ($receiver, $self) {
					// get method arguments and append receiver	
					$arguments = \eGloo\Utilities\Collection::flatten(func_get_args());
					$arguments[] = $receiver;
						
					// use reflection to call protected method delegate	
					$reflection = new \ReflectionMethod($self, 'delegate');
					$reflection->setAccessible(true);
					
					
					return $reflection->invokeArgs($self, $arguments);
					
				});	
				
				return call_user_func_array($method, $arguments);
			}
			
			throw new \Exception(
				"Failed delegating to receiver '$receiver' because it does not exist"
			);
			
		}
				
		
		// throw exception generated by parent if we have reached this point
		throw $hold;
		//throw new \Exception(
		//	"Unable to delegate instance method $name to receiver "	. get_class($this->delegated)	
		//);
	}
	
	/**
	 * Determines if static method exists on delegated and call on class
	 * scope
	 */
	public static function __callstatic($name, $arguments) {
		try { 
			return parent::__callstatic($name, $arguments);
		}
		
		catch(\Exception $hold) {}

		if (isset(static::$associated[$class = get_called_class()]) && 
			 (method_exists($delegated = static::$associated[$class], $name) ||
			 isset(static::$_methodsStatic[$class][$name]))) {
			
			return call_user_func_array(
				"$delegated::$name", $arguments	
			);
		}
			 
		// check delegated-to for method; if there is method name overlap
		// then the first method found will be called 
		if (isset(static::$delegatedToStatic[$class = static::classNameFull()])) {
			$delegatedTo = static::$delegatedToStatic[$class];
			
			foreach($delegatedTo as $class => $delegated) {
				if (in_array($name, $delegated['methods'])) {
					try { 
						return call_user_func_array(
							array($delegated['receiver'], $name), $arguments
						);
					}
					
					catch(\Exception $passthrough) {
						throw new $passthrough;
					}
				}
			}		
		}	 
		
		// throw exception generated by parent callstatic
		throw $hold;
	
		// defer to parent if not able to delegate
		//return parent::__callstatic($name, $arguments);
	}
	
	/**
	 * Provides a way to statically associate proxies
	 */
	public static function delegate($from, $to) {
		static::$associated[$from] = $to;
	}
	
	/**
	 * Allows for granular delegation to of methods on a specific
	 * receiver
	 */
	protected static function delegates($__mixed) {
		$arguments = Collection::flatten(func_get_args()); 
		
		if (count($arguments) >= 2) {
		
			$receiver = $arguments['to'];
			$methods  = array_slice($arguments, 0, count($arguments) - 2);
			
			
			if (is_object($receiver) && 
			    !isset(static::$delegatedToStatic[static::classnamefull()][get_class($receiver)])) {
			    	
				static::$delegatedToStatic[static::classNameFull()][get_class($receiver)] = array(
					'receiver' => $receiver,
					'methods'  => $methods
				);
			}
		}
		
		else {
			throw new \Exception(
				"Failed call to delegates because argument list must include at least one method and one receiver : " . print_r(
					$arguments
			));
		}
	}
	
	
	
	protected static $associated        = array();
	protected static $delegatedToStatic = array();	
	protected        $delegatedTo       = array();  
	protected        $delegated         = array();  
}